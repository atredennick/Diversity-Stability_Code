Spars$intcpt,yr=Spars$intcpt.yr+Spars$intcpt.gr[doGroup,]
Gpars$intcpt=Gpars$intcpt.yr+Gpars$intcpt.gr[doGroup,]
Rpars$intcpt.yr=Rpars$intcpt.yr+matrix(Rpars$intcpt.gr[doGroup,],Nyrs,Nspp,byrow=T)
}
if(!is.na(doGroup)){
Spars$intcpt.yr=Spars$intcpt.yr+Spars$intcpt.gr[doGroup,]
Gpars$intcpt.yr=Gpars$intcpt.yr+Gpars$intcpt.gr[doGroup,]
Rpars$intcpt.yr=Rpars$intcpt.yr+matrix(Rpars$intcpt.gr[doGroup,],Nyrs,Nspp,byrow=T)
}
Spars
#draw from observed year effects
allYrs=c(1:Nyrs)
doYear=sample(allYrs,1)
yrSave[t]=doYear
#get recruits per area
cover=covSave[t-1,]; N=Nsave[t-1,]
rpa=get.rpa(Rpars,cover,doYear)
covSave[t-1,]
Nsave[t-1,]
t
Rpars
source("./recruitment/import2ipm_MCMC.r")
Rpars
if(!is.na(doGroup)){
Spars$intcpt.yr=Spars$intcpt.yr+Spars$intcpt.gr[doGroup,]
Gpars$intcpt.yr=Gpars$intcpt.yr+Gpars$intcpt.gr[doGroup,]
Rpars$intcpt.yr=Rpars$intcpt.yr+matrix(Rpars$intcpt.gr[doGroup,],Nyrs,Nspp,byrow=T)
}
Rpars
#draw from observed year effects
allYrs=c(1:Nyrs)
doYear=sample(allYrs,1)
yrSave[t]=doYear
cover=covSave[t-1,]; N=Nsave[t-1,]
cover
Rpars
doYear
rpa=get.rpa(Rpars,cover,doYear)
#calculate size-specific crowding
alphaG=Gpars$alpha
alphaS=Spars$alpha
if(NoOverlap.Inter==F){#T: heterospecific genets cannot overlap; F: overlap allowed
for(ii in 1:Nspp){
# first do all overlap W's
Xbar=cover*A/N       # multiply by A to get cover back in cm^2
varX=varN(v,nt,h,Xbar,N)
muWG = pi*Xbar*N/(A*alphaG[ii,])
muWS = pi*Xbar*N/(A*alphaS[ii,])
muWG[is.na(muWG)]=0
muWS[is.na(muWS)]=0
WmatG[[ii]]=matrix(muWG,nrow=length(v[[ii]]),ncol=Nspp,byrow=T)
WmatS[[ii]]=matrix(muWS,nrow=length(v[[ii]]),ncol=Nspp,byrow=T)
# now do conspecific no overlap W
Ctot[ii]=h[ii]*sum(expv[[ii]]*nt[[ii]])
Cr[[ii]]=splinefun(b.r[[ii]],h[ii]*c(0,cumsum(expv[[ii]]*nt[[ii]])),method="natural")
WmatG[[ii]][,ii]=WrijG(v.r[[ii]],ii,ii)/A
WmatS[[ii]][,ii]=WrijS(v.r[[ii]],ii,ii)/A
}
}else{
for(ii in 1:Nspp){
Ctot[ii]=h[ii]*sum(expv[[ii]]*nt[[ii]])
Cr[[ii]]=splinefun(b.r[[ii]],h[ii]*c(0,cumsum(expv[[ii]]*nt[[ii]])),method="natural")
}
for(jj in 1:Nspp){
WfunG=splinefun(size.range,WrijG(size.range,jj,jj))
WfunS=splinefun(size.range,WrijS(size.range,jj,jj))
for(ii in 1:Nspp) {
WmatG[[ii]][,jj]=WfunG(v.r[[ii]])/A
WmatS[[ii]][,jj]=WfunS(v.r[[ii]])/A
}
}
} # end NoOverlap if
for(doSpp in 1:Nspp){
if(cover[doSpp]>0){
# make kernels and project
K.matrix=make.K.matrix(v[[doSpp]],WmatG[[doSpp]],WmatS[[doSpp]],Rpars,rpa,Gpars,Spars,doYear,doSpp)
new.nt[[doSpp]]=K.matrix%*%nt[[doSpp]]
sizeSave[[doSpp]][,i]=new.nt[[doSpp]]/sum(new.nt[[doSpp]])
}
} # next species
nt=new.nt
covSave[t,]=sumCover(v,nt,h,A)  # store the cover as cm^2/cm^2
Nsave[t,]=sumN(nt,h)
print(t)
print(paste("Done with year",t))
setwd("~/Repos/Diversity_Stability/PopModels/idahoIPM/multispp_glm_v4")
# Multispecies, spatially implicit IPM
# This version makes it possible to assume "no overlap"
# for intraspecific competition only or intra- and interspecific competition
# ATT 8/26/14
# outfile1="ipm_cover.csv"
# outfile2="stable_size.csv"
# obsClimateFile="Climate.csv"
perturbPpt=F
perturbTemp=F
# climYrSave=read.csv("climYears.csv")  # use same sequence of years used for observed run
# randYrSave=read.csv("randYears.csv")
A=10000 #Area of 100cm x 100cm quadrat
tlimit=2500 ## number of years to simulate
burn.in=500    # years to cut before calculations
sppList=c("ARTR","HECO","POSE","PSSP")
bigM=c(75,75,50,50)     #Set matrix dimension for each species
maxSize=c(3000,202,260,225)    # in cm^2: PSSP=225 HECO=202  POSE=260  ARTR=3000  # minSize=0.2  cm^2
Nyrs=22
doGroup=NA  # NA for spatial avg., values 1-6 for a specific group
constant=F
NoOverlap.Inter=F
compScale=F
#============================================================
# (I) LOAD VITAL RATE PARAMETERS & FUNCTIONS
#============================================================
Nspp=length(sppList)
SparsMCMC <- readRDS("./survival/survivalParamsMCMC4IPM.rds")
GparsMCMC <- readRDS("./growth/growthParamsMCMC4IPM.rds")
## survival function: probability an individual of size u survives  (u is on log scale)
S=function(u,W,Spars,doYear,doSpp){
mu=Spars$intcpt.yr[doYear,doSpp]+(Spars$slope[doSpp]+Spars$slope.yr[doYear,doSpp])*u+
W%*%(Spars$nb[doSpp,])
return(inv.logit(mu))
}
## growth function
G=function(v,u,W,Gpars,doYear,doSpp){
mu=Gpars$intcpt.yr[doYear,doSpp]+
(Gpars$slope[doSpp]+Gpars$slope.yr[doYear,doSpp])*u+
W%*%(Gpars$nb[doSpp,])
sigma2=Gpars$sigma2.a[doSpp]*exp(Gpars$sigma2.b[doSpp]*mu)
out=dnorm(v,mu,sqrt(sigma2))
out
}
#============================================================================================#
# (II) Simulation length, Matrix size and initial vectors
#============================================================================================#
v=v.r=b.r=expv=Cr=WmatG=WmatS=list(4)
h=r.L=r.U=Ctot=numeric(4)
for(i in 1:Nspp){
# minimum (0.9*minimum size from data) and maximum sizes (1.1*maximum size from data)
L=log(0.2)
U=log(maxSize[i])*1.1
# boundary points b and mesh points y. Note: b chops up the size interval (L-U) into bigM-equal-sized portions.
b = L+c(0:bigM[i])*(U-L)/bigM[i]
# v calculates the middle of each n-equal-sized portion.
v[[i]] = 0.5*(b[1:bigM[i]]+b[2:(bigM[i]+1)])
# step size for midpoint rule. (see equations 4 and 5 in Ellner and Rees (2006) Am Nat.)
h[i] = v[[i]][2]-v[[i]][1]
# variables for Wr approximation
b.r[[i]]=sqrt(exp(b)/pi)
v.r[[i]]=sqrt(exp(v[[i]])/pi)
expv[[i]]=exp(v[[i]])
r.L[i] = sqrt(exp(L)/pi)
r.U[i] = sqrt(exp(U)/pi)
WmatG[[i]]=matrix(NA,length(v.r[[i]]),Nspp)  # storage of size-specific W values for each focal species
WmatS[[i]]=matrix(NA,length(v.r[[i]]),Nspp)
} # next species
tmp=range(v.r)
size.range=seq(tmp[1],tmp[2],length=50) # range across all possible sizes
#============================================================================================#
# (III) Utility functions
#============================================================================================#
# load the necessary libraries
library(boot)
library(mvtnorm)
library(msm)
library(statmod)
## combined kernel
make.K.values=function(v,u,muWG,muWS, #state variables
Rpars,rpa,Gpars,Spars,doYear,doSpp){  #growth arguments
f(v,u,Rpars,rpa,doSpp)+S(u,muWS,Spars,doYear,doSpp)*G(v,u,muWG,Gpars,doYear,doSpp)
}
# Function to make iteration matrix based only on mean crowding
make.K.matrix=function(v,muWG,muWS,Rpars,rpa,Gpars,Spars,doYear,doSpp) {
muWG=expandW(v,v,muWG)
muWS=expandW(v,v,muWS)
K.matrix=outer(v,v,make.K.values,muWG,muWS,Rpars,rpa,Gpars,Spars,doYear,doSpp)
return(h[doSpp]*K.matrix)
}
# Function to format the W matrix for the outer product
expandW=function(v,u,W){
if(dim(W)[1]!=length(u)) stop("Check size of W")
Nspp=dim(W)[2]
W=as.vector(W)
W=matrix(W,length(W),ncol=length(v))
W=as.vector(t(W))
W=matrix(W,nrow=length(u)*length(v),ncol=Nspp)
return(W)
}
# Function to calculate size-dependent crowding, assuming no overlap
wrijG=function(r,i,j){
return(2*pi*integrate(function(z) z*exp(-alphaG[i,j]*(z^2))*Cr[[j]](z-r),r,r+r.U[j])$value+
pi*Ctot[j]*exp(-alphaG[i,j]*((r+r.U[j])^2))/alphaG[i,j]);
}
WrijG=Vectorize(wrijG,vectorize.args="r")
wrijS=function(r,i,j){
return(2*pi*integrate(function(z) z*exp(-alphaS[i,j]*(z^2))*Cr[[j]](z-r),r,r+r.U[j])$value+
pi*Ctot[j]*exp(-alphaS[i,j]*((r+r.U[j])^2))/alphaS[i,j]);
}
WrijS=Vectorize(wrijS,vectorize.args="r")
# Function to sum total cover of each species
sumCover=function(v,nt,h,A){
out=lapply(1:Nspp,function(i,v,nt,h,A) h[i]*sum(nt[[i]]*exp(v[[i]]))/A,v=v,nt=nt,h=h,A=A)
return(unlist(out))
}
# Function to sum total density of each species
sumN=function(nt,h){
out=lapply(1:Nspp,function(i,nt,h) h[i]*sum(nt[[i]]),nt=nt,h=h)
return(unlist(out))
}
# Function to calculate size variance of each species
varN=function(v,nt,h,Xbar,N){
out=lapply(1:Nspp,function(i,v,nt,h,Xbar,N) h[i]*sum((exp(v[[i]]-Xbar[i])^2)*nt[[i]])/N[i],v=v,nt=nt,h=h,Xbar=Xbar,N=N)
return(unlist(out))
}
# Function to do an image plot of a matrix in the usual orientation, A(1,1) at top left
matrix.image=function(x,y,A,col=topo.colors(100),...) {
nx=length(x); ny=length(y);
x1=c(1.5*x[1]-0.5*x[2],1.5*x[nx]-0.5*x[nx-1]);
y1=c(1.5*y[1]-0.5*y[2],1.5*y[ny]-0.5*y[ny-1]);
image(list(x=x,y=y,z=t(A)),xlim=x1,ylim=rev(y1),col=col,bty="u",...);
}
#============================================================================================#
# (IV) Calculate the equilibrium areas.
#============================================================================================#
## initial population density vector
nt=v
for(i in 1:Nspp) nt[[i]][]=0.1
new.nt=nt
## initial population density vector
# set up matrix to record cover
covSave = matrix(NA,tlimit,Nspp)
covSave[1,]=sumCover(v,nt,h,A)
# set up list to store size distributions
sizeSave=list(NULL)
for(i in 1:Nspp){
sizeSave[[i]]=matrix(NA,length(v[[i]]),(tlimit))
sizeSave[[i]][,1]=nt[[i]]/sum(nt[[i]])
}
# initial densities
Nsave=matrix(NA,tlimit,Nspp)
Nsave[1,]=sumN(nt,h)
yrSave=rep(NA,tlimit)
for (t in 2:(tlimit)){
#get growth and survival parameters
Gpars <- GparsMCMC[[t]]
Spars <- SparsMCMC[[t]]
# set up recruitment parameters and function
source("./recruitment/import2ipm_MCMC.r")
# model spatial group variation (or not)
if(!is.na(doGroup)){
Spars$intcpt.yr=Spars$intcpt.yr+Spars$intcpt.gr[doGroup,]
Gpars$intcpt.yr=Gpars$intcpt.yr+Gpars$intcpt.gr[doGroup,]
Rpars$intcpt.yr=Rpars$intcpt.yr+matrix(Rpars$intcpt.gr[doGroup,],Nyrs,Nspp,byrow=T)
}
#draw from observed year effects
allYrs=c(1:Nyrs)
doYear=sample(allYrs,1)
yrSave[t]=doYear
#get recruits per area
cover=covSave[t-1,]; N=Nsave[t-1,]
rpa=get.rpa(Rpars,cover,doYear)
#calculate size-specific crowding
alphaG=Gpars$alpha
alphaS=Spars$alpha
if(NoOverlap.Inter==F){#T: heterospecific genets cannot overlap; F: overlap allowed
for(ii in 1:Nspp){
# first do all overlap W's
Xbar=cover*A/N       # multiply by A to get cover back in cm^2
varX=varN(v,nt,h,Xbar,N)
muWG = pi*Xbar*N/(A*alphaG[ii,])
muWS = pi*Xbar*N/(A*alphaS[ii,])
muWG[is.na(muWG)]=0
muWS[is.na(muWS)]=0
WmatG[[ii]]=matrix(muWG,nrow=length(v[[ii]]),ncol=Nspp,byrow=T)
WmatS[[ii]]=matrix(muWS,nrow=length(v[[ii]]),ncol=Nspp,byrow=T)
# now do conspecific no overlap W
Ctot[ii]=h[ii]*sum(expv[[ii]]*nt[[ii]])
Cr[[ii]]=splinefun(b.r[[ii]],h[ii]*c(0,cumsum(expv[[ii]]*nt[[ii]])),method="natural")
WmatG[[ii]][,ii]=WrijG(v.r[[ii]],ii,ii)/A
WmatS[[ii]][,ii]=WrijS(v.r[[ii]],ii,ii)/A
}
}else{
for(ii in 1:Nspp){
Ctot[ii]=h[ii]*sum(expv[[ii]]*nt[[ii]])
Cr[[ii]]=splinefun(b.r[[ii]],h[ii]*c(0,cumsum(expv[[ii]]*nt[[ii]])),method="natural")
}
for(jj in 1:Nspp){
WfunG=splinefun(size.range,WrijG(size.range,jj,jj))
WfunS=splinefun(size.range,WrijS(size.range,jj,jj))
for(ii in 1:Nspp) {
WmatG[[ii]][,jj]=WfunG(v.r[[ii]])/A
WmatS[[ii]][,jj]=WfunS(v.r[[ii]])/A
}
}
} # end NoOverlap if
for(doSpp in 1:Nspp){
if(cover[doSpp]>0){
# make kernels and project
K.matrix=make.K.matrix(v[[doSpp]],WmatG[[doSpp]],WmatS[[doSpp]],Rpars,rpa,Gpars,Spars,doYear,doSpp)
new.nt[[doSpp]]=K.matrix%*%nt[[doSpp]]
sizeSave[[doSpp]][,i]=new.nt[[doSpp]]/sum(new.nt[[doSpp]])
}
} # next species
nt=new.nt
covSave[t,]=sumCover(v,nt,h,A)  # store the cover as cm^2/cm^2
Nsave[t,]=sumN(nt,h)
print(paste("Done with year",t))
flush.console()
if(sum(is.na(nt))>0) browser()
} # next time step
boxplot(as.data.frame(100*covSave[(burn.in+1):tlimit,]),ylab="Cover (%)",names=sppList,col=myCol)
myCol=c("black","gold","blue","red")
#cover
boxplot(as.data.frame(100*covSave[(burn.in+1):tlimit,]),ylab="Cover (%)",names=sppList,col=myCol)
boxplot(as.data.frame(Nsave[(burn.in+1):tlimit,]),ylab="Density",names=sppList,col=myCol)
abline(h=0)
plot(1,1,type="n",xlim=c(log(0.15),log(max(maxSize))),ylim=c(0,0.1),
xlab="Size",ylab="Frequency")
for(i in 1:Nspp){
lines(v[[i]],rowMeans(sizeSave[[i]][,(burn.in+1):tlimit]),col=myCol[i], lwd=3)
}
rowMeans(sizeSave[[i]][,(burn.in+1):tlimit])
sizeSave
matplot((burn.in+1):tlimit,100*covSave[(burn.in+1):tlimit,],type="l",col=myCol,
xlab="Time",ylab="Cover (%)")
totalCov <- apply(X = covSave[(burn.in+1):tlimit,], MARGIN = 1, FUN = sum)
lim <- 10000
cvVec <- numeric(lim)
for(i in 1:lim){
tmp <- sample(seq(1,(length(totalCov)-22)), 1)
tmp2 <- seq(tmp,tmp+21)
tmpCov <- totalCov[tmp2]
cvVec[i] <- (sd(tmpCov))/mean(tmpCov)
}
par(mfrow=c(1,1),tcl=-0.2,mgp=c(2,0.5,0))
plot(density(cvVec, adjust=4), lwd=4, main="", xlab="community temporal CV", col="dodgerblue",
ylab="estimated probability density")
abline(v = median(cvVec), lty=3, col="coral", lwd=3)
abline(v=0.2, lwd=3, lty=1)
setwd("~/Repos/Diversity_Stability/PopModels/idahoIPM/multispp_glm_v4")
################################################################################
# Below is an IBM for simulating long-term population dynamics with demographic
#   and environmental stochasticity. Parameters for vital rate functions come
#   from previously fit statistical models.
#
# email: atredenn@gmail.com
################################################################################
## Required libraries:
library(boot) #for inverse logit function (inv.logit)
################################################################################
## Some global variables:
nSims=5
nYrs=22
nGrps=6
#startYr=32
#doGroup=6
L=100 # dimension of square quadrat (cm)
expand=1  # 1 = 1x1 m^2, 2 = 2x2m^2, etc
sppList=c("ARTR","HECO","POSE","PSSP")
minSize=0.25
maxSize=c(8000,500,500,500)
################################################################################
# Below is an IBM for simulating long-term population dynamics with demographic
#   and environmental stochasticity. Parameters for vital rate functions come
#   from previously fit statistical models.
#
# email: atredenn@gmail.com
################################################################################
## Clear the workspace:
rm(list=ls(all=TRUE))
################################################################################
## Required libraries:
library(boot) #for inverse logit function (inv.logit)
################################################################################
## Some global variables:
nSims=5
nYrs=22
nGrps=6
#startYr=32
#doGroup=6
L=100 # dimension of square quadrat (cm)
expand=1  # 1 = 1x1 m^2, 2 = 2x2m^2, etc
sppList=c("ARTR","HECO","POSE","PSSP")
minSize=0.25
maxSize=c(8000,500,500,500)
################################################################################
## Vital rate functions:
survive=function(Spars,doSpp,doYear,sizes,crowding){
logsizes=log(sizes)
mu=Spars$intcpt.yr[doYear,doSpp]+Spars$slope.yr[doYear,doSpp]*logsizes+Spars$nb[doSpp,]%*%crowding
out=inv.logit(mu)
out=rbinom(length(sizes),1,out)
out
}
grow=function(Gpars,doSpp,doYear,sizes,crowding){
# crowding and nb are vectors of dim Nspp
logsizes=log(sizes)
mu=Gpars$intcpt.yr[doYear,doSpp]+Gpars$slope.yr[doYear,doSpp]*logsizes+Gpars$nb[doSpp,]%*%crowding
tmp=which(mu<log(minSize)*1.5)  # we will kill vanishingly small plants...below
mu[tmp]=log(minSize) # truncate tiny sizes (they cause problems in sigma2)
sigma2=Gpars$sigma2.a[doSpp]*exp(Gpars$sigma2.b[doSpp]*mu)
out=exp(rnorm(length(sizes),mu,sqrt(sigma2)))
if(sum(is.na(out))>0) browser()
out[tmp]=0   # here's the killing of really small plants
out[out>maxSize[doSpp]]=maxSize[doSpp] #truncate big plants for maximum observed size
out
}
recruit=function(Rpars,sizes,spp,doYear,lastID,L,expand){
# dd is a matrix of dim Nspp X Nspp
# sizes and spp are vectors of the same length (=N plants)
# calculate total areas
totArea=aggregate(sizes,by=list("spp"=spp),FUN=sum)
# put in missing zeros
tmp=data.frame("spp"=1:length(sppList))
totArea=merge(totArea,tmp,all.y=T)
totArea[is.na(totArea)]=0
totArea=totArea[,2]/((L*expand)^2)*100  # scale to % cover
# calculate recruits
lambda=rep(NA,Nspp) # seed production
for(i in 1:Nspp){
lambda[i]=totArea[i]*exp(Rpars$intcpt.yr[doYear,i]+sqrt(totArea)%*%Rpars$dd[i,])
}
# number of draws from distribution depends on size of landscape
NN=rnbinom(length(lambda)*expand^2,mu=lambda,size=Rpars$theta)
NN=rowSums(matrix(NN,length(lambda),expand^2))
x=y=spp=id=size=NULL
for(i in 1:Nspp){
if(NN[i]>0){
#get recruit sizes
size=c(size,exp(rnorm(NN[i],Rpars$sizeMean[i],sqrt(Rpars$sizeVar[i]))))
if(sum(is.na(size))>0) stop("Check recruit sizes")
#assign random coordinates
x=c(x,expand*L*runif(NN[i])); y=c(y,expand*L*runif(NN[i]))
spp=c(spp,rep(i,NN[i]))
#assign genet ID's
if(length(id)>0) lastID=max(id)
id=c(id,(1:NN[i]+lastID))
}
} # next i
# output
size[size<minSize]=minSize
out=cbind(spp,size,x,y,id)
return(out)
}
# crowding function, assumes toroidal landscape
getCrowding=function(plants,alpha,L,expand){
# plants is a matrix: sizes in column 1; x,y coords in columns 2 and 3
# d is the distance weighting parameter
# function returns a vector of length = rows in plants
if(dim(plants)[1]>1){
xdiff=abs(outer(plants[,3],plants[,3],FUN="-"))
ydiff=abs(outer(plants[,4],plants[,4],FUN="-"))
distMat=sqrt(xdiff^2+ydiff^2)
distMat[distMat==0]=NA
#distMat[distMat<1]=1  # CLUDGE TO PREVENT GROWTH EXPLOSIONS
distMat=exp(-1*alpha[plants[,1]]*distMat^2)
sizeMat=matrix(plants[,2],dim(plants)[1],dim(plants)[1])
out=aggregate(distMat*sizeMat,by=list("spp"=plants[,1]),FUN=sum,na.rm=T)
# put in missing zeros
tmp=data.frame("spp"=c(1:length(sppList)))
out=merge(out,tmp,all.y=T)
out[is.na(out)]=0
out=out[order(out$spp),]
out=as.matrix(out[,c(2:NCOL(out))])  # drop spp column
}else{
out=rep(0,Nspp)
}
out
}
################################################################################
# Function to simulate community:
simComm <- function(nYrs, nSims, nSpp, doGroup){
bigA=array(NA,dim=c((nYrs+1),nSpp,nSims))
bigN=array(NA,dim=c((nYrs+1),nSpp,nSims))
}
Nspp=length(sppList)
init.plants=list(NULL,NULL,NULL,NULL,NULL)
lastID=rep(0,4)
i=1
infile=paste("../speciesData/",sppList[i],"/",sppList[i],"_genet_xy.csv",sep="")
tmpD=read.csv(infile)
head(tmpD)
startYr=32
qName="Q1"
min(tmpD$year)
unique(tmpD$year)
tmpD=subset(tmpD,quad==qName & tmpD$year==min(tmpD$year))
head(tmpD)
tmpD=read.csv(infile)
tmpD=subset(tmpD, tmpD$year==min(tmpD$year))
head(tmpD)
spp=rep(i,dim(tmpD)[1])
spp
tmpD2=data.frame(cbind(spp,tmpD2[,c("area","x","y")]))
tmpD2=data.frame(cbind(spp,tmpD[,c("area","x","y")]))
head(tmpD)
head(tmpD2)
init.plants=list(NULL)
init.plants=rbind(init.plants,tmpD2)
Nspp=length(sppList)
init.plants=list(NULL)
lastID=rep(0,4)
for(i in 1:length(sppList)){
infile=paste("../speciesData/",sppList[i],"/",sppList[i],"_genet_xy.csv",sep="")
tmpD=read.csv(infile)
tmpD=subset(tmpD, tmpD$year==min(tmpD$year))
spp=rep(i,dim(tmpD)[1])
tmpD2=data.frame(cbind(spp,tmpD[,c("area","x","y")]))
names(tmpD2)=c("spp","size","x","y")
init.plants=rbind(init.plants,tmpD2)
}
myCol=c("black","gold1","blue","red")
par(mgp=c(2,0.5,0),tcl=-0.2)
symbols(x = init.plants[,3], y = init.plants[,4], circles = sqrt(init.plants[,2]/pi), fg=myCol[init.plants[,1]],
xlim=c(0,L*expand),ylim=c(0,L*expand),main ="Time=1",xlab="x",ylab="y",inches=F,lwd=2)
