y <- (0.142*x - 14.2)
y[y<0] <- 0
y[y>100] <- 100
y <- y*runif(10000,0,1)
####
#### Fit the GAM
####
mod <- gam(y ~ s(x))
modP <- predict(mod, newdata = data.frame(x=c(1:2000)))
####
#### Plot the results
####
plot(x, y, pch=".")
lines(x, modP)
####
#### Example GAM fit through big, noisy data
####
library(gam)
####
#### Simulate some data
####
x <- runif(10000, 100, 2000)
y <- (0.142*x - 14.2)
y[y<0] <- 0
y[y>100] <- 100
y <- y*runif(10000,0,1)
####
#### Fit the GAM
####
mod <- gam(y ~ s(x))
modP <- predict(mod, newdata = data.frame(x=c(1:2000)))
####
#### Plot the results
####
plot(x, y, pch=".")
lines(c(1:2000), modP)
lines(c(1:2000), modP, col="dodgerblue")
lines(c(1:2000), modP, col="dodgerblue", lwd=4)
####
#### Example GAM fit through big, noisy data
####
library(gam)
####
#### Simulate some data
####
x <- runif(10000, 100, 2000)
y <- (0.142*x - 14.2)
y[y<0] <- 0
y[y>100] <- 100
y <- y*runif(10000,0,1)
####
#### Fit the GAM
####
mod <- gam(y ~ s(x))
modP <- predict(mod, newdata = data.frame(x=c(1:2000)))
####
#### Plot the results
####
plot(x, y, pch=".")
lines(c(1:2000), modP, col="dodgerblue", lwd=4)
####
#### Example GAM fit through big, noisy data
####
library(gam)
####
#### Simulate some data
####
x <- runif(10000, 100, 2000)
y <- (0.142*x - 14.2)
y[y<0] <- 0
y[y>100] <- 100
y <- y*runif(10000,0,1)
####
#### Fit the GAM
####
mod <- gam(y ~ s(x))
modP <- predict(mod, newdata = data.frame(x=c(1:2000)))
####
#### Plot the results
####
plot(x, y, pch=21, cex=0.5)
lines(c(1:2000), modP, col="dodgerblue", lwd=4)
60+75*3
+55
285+55
20*5
#This script pulls in the DICs and then selects/fits the best model for each species
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#
# Set working directory to location of this source file #
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#
#clear everything, just to be safe
rm(list=ls(all=TRUE))
#load libraries
library(INLA)
par(mar=rep(0,4))
plot(NA, NA, xlim=c(-1.3,1), ylim=c(-1, 1.3), xlab="", ylab="", frame.plot=FALSE, xaxt="n", yaxt="n")
for(i in -85:-11){
lines(0.7*(sin(c(i, i+1)/180*pi)-0.4*((i+90)/360))+0.035, 0.7*cos(c(i, i+1)/180*pi), lwd=2, col="steelblue4")
#lwd=2+2*((i+90)/360), col="steelblue4")
}
i=-70
arrows(0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.0351, 0.7*cos(c(i)/180*pi), 0.7*(sin(c(i+.1)/180*pi)-0.4*((i+90)/360))+0.035, 0.7*cos(c(i+.1)/180*pi), lwd=2, col="steelblue4", length=0.1)
i=-47.5
text((0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035)*.85, 0.7*cos(c(i)/180*pi)*.85, expression(s[ad1]), cex=0.75)
i=-3.5
lines(rep(0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035, 2), c(0.7*cos(c(i)/180*pi), 0.7*cos(c(i)/180*pi)-0.4), col="steelblue4")
points(0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035, 0.7*cos(c(i)/180*pi), pch=21, cex=1.5, lwd=2, col="steelblue4", bg="white")
text(0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035-0.03, 0.7*cos(c(i)/180*pi)-0.25, "Larvae in", cex=0.75, col="steelblue4", pos=4)
text(0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035-0.03, 0.7*cos(c(i)/180*pi)-0.32, "additional", cex=0.75, col="steelblue4", pos=4)
text(0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035-0.03, 0.7*cos(c(i)/180*pi)-0.39, "dormancy", cex=0.75, col="steelblue4", pos=4)
for(i in 3:255){
lines(0.7*(sin(c(i, i+1)/180*pi)-0.4*((i+90)/360))+0.035, 0.7*cos(c(i, i+1)/180*pi), lwd=2, col="steelblue4")
#, lwd=2+2*((i+90)/360), col="steelblue4")
}
i=129.5
text((0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035)*.85, 0.7*cos(c(i)/180*pi)*.8, expression(s[ad2]), cex=0.75)
i=-68
arrows(1*sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20, 1*cos(c(i)/180*pi), 1*sin(c(i+.05)/180*pi)+0.28*((i+90)/360)-0.20, 1*cos(c(i+.05)/180*pi), lwd=2, col="chartreuse4", length=0.1)
for(i in -85:-5){
lines(1*sin(c(i, i+1)/180*pi)+0.28*((i+90)/360)-0.20, 1*cos(c(i, i+1)/180*pi), lwd=2, col="chartreuse4")
#, lwd=6-2*((i+90)/360), col="chartreuse4")
}
i=-45
text((sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20)*1.07, cos(i/180*pi)*1.1, expression(s[n]), cex=0.75)
i=0.5
lines(rep(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20, 2), c(cos(i/180*pi), cos(i/180*pi)+0.16), col="chartreuse4")
points(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20, cos(i/180*pi), pch=21, cex=1.5, lwd=2, col="chartreuse4", bg="white")
text(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20-0.03, cos(i/180*pi)+0.14, "Adults", cex=0.75, col="chartreuse4", pos=4)
for(i in 5:31){
lines(1*sin(c(i, i+1)/180*pi)+0.28*((i+90)/360)-0.20, 1*cos(c(i, i+1)/180*pi), lwd=2, col="chartreuse4")
#, lwd=6-2*((i+90)/360), col="chartreuse4")
}
i=18
text((sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20)*0.9, cos(i/180*pi)*0.9, expression(F%*%tau), cex=0.75)
i=36.5
lines(rep(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20, 2), c(cos(i/180*pi), cos(i/180*pi)+0.32), col="chartreuse4")
points(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20, cos(i/180*pi), pch=21, cex=1.5, lwd=2, col="chartreuse4", bg="white")
text(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20-0.03, cos(i/180*pi)+0.3, "Eggs in", cex=0.75, col="chartreuse4", pos=4)
text(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20-0.03, cos(i/180*pi)+0.23, "chestnuts", cex=0.75, col="chartreuse4", pos=4)
for(i in 41:67){
lines(1*sin(c(i, i+1)/180*pi)+0.28*((i+90)/360)-0.20, 1*cos(c(i, i+1)/180*pi), lwd=2, col="chartreuse4")
#, lwd=6-2*((i+90)/360), col="chartreuse4")
}
i=54
text((sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20)*.9, cos(i/180*pi)*.9, expression(s[bb]), cex=0.75)
i=72.5
lines(c(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20, sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20+0.07), c(cos(i/180*pi), cos(i/180*pi)), col="chartreuse4")
lines(rep(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20+0.07, 2), c(cos(i/180*pi), cos(i/180*pi)+0.47), col="chartreuse4")
points(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20, cos(i/180*pi), pch=21, cex=1.5, lwd=2, col="chartreuse4", bg="white")
text(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20+0.07+0.03, cos(i/180*pi)+0.45, "Buried", cex=0.75, col="chartreuse4", pos=2)
text(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20+0.07+0.03, cos(i/180*pi)+0.38, "larvae", cex=0.75, col="chartreuse4", pos=2)
for(i in 77:104){
lines(1*sin(c(i, i+1)/180*pi)+0.28*((i+90)/360)-0.20, 1*cos(c(i, i+1)/180*pi), lwd=2, col="chartreuse4")
#, lwd=6-2*((i+90)/360), col="chartreuse4")
}
i=135
text((sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20)*0.9, cos(i/180*pi)*0.9, expression(s[fd]), cex=0.75)
for(i in 110:260){
lines(1*sin(c(i, i+1)/180*pi)+0.28*((i+90)/360)-0.20, 1*cos(c(i, i+1)/180*pi), lwd=2, col="chartreuse4")
#, lwd=6-2*((i+90)/360), col="chartreuse4")
}
i=107.5
lines(c(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20, sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20+0.07), c(cos(i/180*pi), cos(i/180*pi)), col="chartreuse4")
lines(rep(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20+0.07, 2), c(cos(i/180*pi), cos(i/180*pi)-0.7), col="chartreuse4")
points(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20, cos(i/180*pi), pch=19, cex=0.5, lwd=1, col="chartreuse4", bg="white")
text(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20+0.07+0.03, cos(i/180*pi)-0.47, "Larvae", cex=0.75, col="chartreuse4", pos=2)
text(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20+0.07+0.03, cos(i/180*pi)-0.54, "in first", cex=0.75, col="chartreuse4", pos=2)
text(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20+0.07+0.03, cos(i/180*pi)-0.61, "obligatory", cex=0.75, col="chartreuse4", pos=2)
text(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20+0.07+0.03, cos(i/180*pi)-0.68, "dormancy", cex=0.75, col="chartreuse4", pos=2)
i=266
points(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20, cos(i/180*pi), pch=21, cex=1.5, lwd=2, col="black", bg="white")
i=-91
lines(rep(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20, 2), c(cos(i/180*pi), cos(i/180*pi)-0.75), col="chartreuse4")
points(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20, cos(i/180*pi), pch=21, cex=1.5, lwd=2, col="chartreuse4", bg="white")
text(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20-0.03, cos(i/180*pi)-0.6, "Larvae", cex=0.75, col="chartreuse4", pos=4)
text(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20-0.03, cos(i/180*pi)-0.67, "choosing", cex=0.75, col="chartreuse4", pos=4)
text(sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20-0.03, cos(i/180*pi)-0.74, "nymphosis", cex=0.75, col="chartreuse4", pos=4)
i=215
arrows(1*sin(c(i)/180*pi)+0.28*((i+90)/360)-0.20, 1*cos(c(i)/180*pi), 1*sin(c(i+.05)/180*pi)+0.28*((i+90)/360)-0.20, 1*cos(c(i+.05)/180*pi), lwd=2, col="chartreuse4", length=0.1)
i=202
arrows(0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035, 0.7*cos(c(i)/180*pi), 0.7*(sin(c(i+.1)/180*pi)-0.4*((i+90)/360))+0.035, 0.7*cos(c(i+.1)/180*pi), lwd=2, col="steelblue4", length=0.1)
i=-92
lines(c(0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035, 0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035+0.3), c(0.7*cos(c(i)/180*pi), 0.7*cos(c(i)/180*pi)), col="steelblue4")
lines(rep(0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035+0.3, 2), c(0.7*cos(c(i)/180*pi), 0.7*cos(c(i)/180*pi)-0.2), col="steelblue4")
points(0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035, 0.7*cos(c(i)/180*pi), pch=21, cex=1.5, lwd=2, col="steelblue4", bg="white")
text(0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035+0.3-0.03, 0.7*cos(c(i)/180*pi)-0.05, "Larvae choosing", cex=0.75, col="steelblue4", pos=4)
text(0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035+0.3-0.03, 0.7*cos(c(i)/180*pi)-0.12, "additional", cex=0.75, col="steelblue4", pos=4)
text(0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035+0.3-0.03, 0.7*cos(c(i)/180*pi)-0.19, "dormancy", cex=0.75, col="steelblue4", pos=4)
arrows((sin(c(266)/180*pi)+0.28*((266+90)/360)-0.20)*1.05, cos(266/180*pi)*1.05+0.01, (sin(c(-91)/180*pi)+0.28*((-91+90)/360)-0.20)*0.95, cos(-91/180*pi)*0.95-0.01, col="black", length=0.07, lwd=1.5)
text(mean(c((sin(c(266)/180*pi)+0.28*((266+90)/360)-0.20)*1.05, (sin(c(-91)/180*pi)+0.28*((-91+90)/360)-0.20)*0.95)), mean(c(cos(266/180*pi)*1.05+0.01, cos(-91/180*pi)*0.95-0.01))-0.07, expression(1-x), cex=0.75)
arrows((sin(c(266)/180*pi)+0.28*((266+90)/360)-0.20)*0.96, cos(266/180*pi)*0.95, (0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035)*1.1, (0.7*cos(c(i)/180*pi))*0.95-0.01, col="black", length=0.07, lwd=1.5)
text(mean(c((sin(c(266)/180*pi)+0.28*((266+90)/360)-0.20)*0.96, (0.7*(sin(c(i)/180*pi)-0.4*((i+90)/360))+0.035)*1.07)), mean(c(cos(266/180*pi)*0.95, (0.7*cos(c(i)/180*pi))*0.95-0.01))-0.07, expression(x), cex=0.75)
3000-(500+550+61+780)
if( ! require( "circlize" , character.only = TRUE ) ){
#  If package was not able to be loaded then re-install
install.packages( "circlize" , dependencies = TRUE )
#  Load package after installing
require( "circlize" , character.only = TRUE )
}
rm(list=ls())
####Start
dev.new <- function(width = 5, height = 5){
platform <- sessionInfo()$platform
if (grepl("linux",platform)) {
x11(width=width, height=height)
}else{
if (grepl("pc",platform)) {
windows(width=width, height=height)
}else{
if (grepl("w32",platform)) {
windows(width=width, height=height)
}else{
if (grepl("apple", platform)){
quartz(width=width, height=height)} }}}}
dev.new(7, 7)
par(mfrow=c(2,2),mar=c(1,1,1,1),bg=sample(c("#FFFAFA","#F8FFFF","#F5FFF9"),1))
for(z in 1:4){
##Random variables
p=sample(c(0,2),1)
s1 <- sample(c(4,6,8),1)
t <- s1*sample(6:8,1)
totals <- rep(80, t)
arms <- sample(c(1,2,2,3,3,4),1)
start_ang <- as.numeric(sample(seq(from=0,to=360), 1))
#cols
flakecols <- c("#B0C4DE", "#CDC5BF", "#FFF9B9", "#E6E6FA", "#CCE5E5", "#F9E4B9", "#FFE1DE", "#FFFFF0", "#6a7374")
cols <- sample(flakecols, 3)
#data
df1 <- data.frame(order=1:t, region=1:t,
rcol = rep(cols,t)[t],
lcol = "#4c4c4c",
stringsAsFactors=FALSE)
df1$xmin <- 0
df1$xmax <- totals
##Plot
circos.clear()
circos.par(cell.padding=c(0,0,0,0), track.margin=c(0.0,0.0), start.degree=start_ang, gap.degree=sample(c(0,5),1))
circos.initialize(factors = df1$region, xlim = cbind(df1$xmin, df1$xmax))
circos.trackPlotRegion(ylim = c(0, 1), factors = df1$region, track.height=0.01,
panel.fun = function(x, y) {
name = get.cell.meta.data("sector.index")
i = get.cell.meta.data("sector.numeric.index")
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
circos.rect(xleft=xlim[1], ybottom=ylim[1], xright=xlim[2], ytop=ylim[2], col = df1$rcol[i], lwd=0.05)
})
index1 <- c(0,0,0,0,0,seq(1:t),0,0,0,0,0)
index2 <- c(t-4,t-3,t-2,t-1,t,seq(1:t),1,2,3,4,5)
for(m in 0:(s1-1)){
aa <- m*t/s1+1
bb <- ifelse((m*t/s1+1+t/2)>t,(m*t/s1+1+t/2)-t,(m*t/s1+1+t/2))
circos.link(sector.index1=df1$region[aa], point1=c(25,27), sector.index2=df1$region[bb], point2=c(4, 5), col = cols[1], border="#4c4c4c", lwd=0.25, w=-0.05)
circos.link(sector.index1=df1$region[aa], point1=c(4, 5), sector.index2=df1$region[bb], point2=c(25, 27), col = cols[1], border="#4c4c4c", lwd=0.25, w=-0.05)
circos.link(sector.index1=df1$region[aa], point1=c(10,20), sector.index2=df1$region[aa], point2=c(10,20), col = cols[1], border="#4c4c4c", h=-0.25, lwd=0.25)
circos.link(sector.index1=df1$region[bb], point1=c(10,20), sector.index2=df1$region[bb], point2=c(10,20), col = cols[1], border="#4c4c4c", h=-0.25, lwd=0.25)
for(i in 1:arms){
cc <- sample(cols,1)
ht=runif(1, min=0.15, max=1)
circos.link(sector.index1=df1$region[index2[which(index1==aa)+i]], point1=c(8, 17), sector.index2=df1$region[index2[which(index1==aa)-i]], point2=c(8,17), col = cc, border="#4c4c4c", lwd=0.15, h=ht, w=1)
circos.link(sector.index1=df1$region[index2[which(index1==bb)+i]], point1=c(8, 17), sector.index2=df1$region[index2[which(index1==bb)-i]], point2=c(8, 17), col = cc, border="#4c4c4c", lwd=0.15, h=ht, w=1)
}
}
}
title(main="Happy Holidays 2014", outer=TRUE, cex.main=2.5, col.main="#8B0000", family="serif",sub="from the EEB & Flow",cex.sub=2,col.sub="#8B0000",line=-2)
##
if( ! require( "circlize" , character.only = TRUE ) ){
#  If package was not able to be loaded then re-install
install.packages( "circlize" , dependencies = TRUE )
#  Load package after installing
require( "circlize" , character.only = TRUE )
}
rm(list=ls())
####Start
dev.new <- function(width = 5, height = 5){
platform <- sessionInfo()$platform
if (grepl("linux",platform)) {
x11(width=width, height=height)
}else{
if (grepl("pc",platform)) {
windows(width=width, height=height)
}else{
if (grepl("w32",platform)) {
windows(width=width, height=height)
}else{
if (grepl("apple", platform)){
quartz(width=width, height=height)} }}}}
dev.new(7, 7)
par(mfrow=c(2,2),mar=c(1,1,1,1),bg=sample(c("#FFFAFA","#F8FFFF","#F5FFF9"),1))
for(z in 1:4){
##Random variables
p=sample(c(0,2),1)
s1 <- sample(c(4,6,8),1)
t <- s1*sample(6:8,1)
totals <- rep(80, t)
arms <- sample(c(1,2,2,3,3,4),1)
start_ang <- as.numeric(sample(seq(from=0,to=360), 1))
#cols
flakecols <- c("#B0C4DE", "#CDC5BF", "#FFF9B9", "#E6E6FA", "#CCE5E5", "#F9E4B9", "#FFE1DE", "#FFFFF0", "#6a7374")
cols <- sample(flakecols, 3)
#data
df1 <- data.frame(order=1:t, region=1:t,
rcol = rep(cols,t)[t],
lcol = "#4c4c4c",
stringsAsFactors=FALSE)
df1$xmin <- 0
df1$xmax <- totals
##Plot
circos.clear()
circos.par(cell.padding=c(0,0,0,0), track.margin=c(0.0,0.0), start.degree=start_ang, gap.degree=sample(c(0,5),1))
circos.initialize(factors = df1$region, xlim = cbind(df1$xmin, df1$xmax))
circos.trackPlotRegion(ylim = c(0, 1), factors = df1$region, track.height=0.01,
panel.fun = function(x, y) {
name = get.cell.meta.data("sector.index")
i = get.cell.meta.data("sector.numeric.index")
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
circos.rect(xleft=xlim[1], ybottom=ylim[1], xright=xlim[2], ytop=ylim[2], col = df1$rcol[i], lwd=0.05)
})
index1 <- c(0,0,0,0,0,seq(1:t),0,0,0,0,0)
index2 <- c(t-4,t-3,t-2,t-1,t,seq(1:t),1,2,3,4,5)
for(m in 0:(s1-1)){
aa <- m*t/s1+1
bb <- ifelse((m*t/s1+1+t/2)>t,(m*t/s1+1+t/2)-t,(m*t/s1+1+t/2))
circos.link(sector.index1=df1$region[aa], point1=c(25,27), sector.index2=df1$region[bb], point2=c(4, 5), col = cols[1], border="#4c4c4c", lwd=0.25, w=-0.05)
circos.link(sector.index1=df1$region[aa], point1=c(4, 5), sector.index2=df1$region[bb], point2=c(25, 27), col = cols[1], border="#4c4c4c", lwd=0.25, w=-0.05)
circos.link(sector.index1=df1$region[aa], point1=c(10,20), sector.index2=df1$region[aa], point2=c(10,20), col = cols[1], border="#4c4c4c", h=-0.25, lwd=0.25)
circos.link(sector.index1=df1$region[bb], point1=c(10,20), sector.index2=df1$region[bb], point2=c(10,20), col = cols[1], border="#4c4c4c", h=-0.25, lwd=0.25)
for(i in 1:arms){
cc <- sample(cols,1)
ht=runif(1, min=0.15, max=1)
circos.link(sector.index1=df1$region[index2[which(index1==aa)+i]], point1=c(8, 17), sector.index2=df1$region[index2[which(index1==aa)-i]], point2=c(8,17), col = cc, border="#4c4c4c", lwd=0.15, h=ht, w=1)
circos.link(sector.index1=df1$region[index2[which(index1==bb)+i]], point1=c(8, 17), sector.index2=df1$region[index2[which(index1==bb)-i]], point2=c(8, 17), col = cc, border="#4c4c4c", lwd=0.15, h=ht, w=1)
}
}
}
title(main="Happy Holidays 2014", outer=TRUE, cex.main=2.5, col.main="#8B0000", family="serif",sub="from the EEB & Flow",cex.sub=2,col.sub="#8B0000",line=-2)
##
5436-550
4886-4500
471-386
2727-1500
setwd("~/Repos/Diversity_Stability/PopModels/idahoIPM/multispp_glm_v4/growth")
list.files()
gP <- readRDS("Growth_paramsMCMC_ARTR.rds")
head(gP)
gP <- readRDS("Growth_paramsMCMC_POSE.rds")
head(gP)
getwd()
big <- list()
for(i in 1:2){
ll <- list(a=1*i, b=2*i)
big <- list(big, ll)
}
big
big[[1]]
big[[1]]$a
big[[2]]$a
big[[3]]$a
big <- list()
big
for(i in 1:2){
ll <- list(a=1*i, b=2*i)
big <- list(big, ll)
}
big
ll
big <- list()
i=1
ll <- list(a=1*i, b=2*i)
ll
big <- list(big, ll)
big
big <- list()
for(i in 1:2){
ll <- list(a=1*i, b=2*i)
big[[length(big)+1] <- ll
}
big <- list()
for(i in 1:2){
ll <- list(a=1*i, b=2*i)
big[[length(big)+1]] <- ll
}
big
big[[1]]
big[[2]]
setwd("~/Repos/Diversity_Stability/PopModels/idahoIPM/multispp_glm_v4")
# Multispecies, spatially implicit IPM
# This version makes it possible to assume "no overlap"
# for intraspecific competition only or intra- and interspecific competition
# ATT 8/26/14
outfile1="ipm_cover.csv"
outfile2="stable_size.csv"
# obsClimateFile="Climate.csv"
perturbPpt=F
perturbTemp=F
# climYrSave=read.csv("climYears.csv")  # use same sequence of years used for observed run
# randYrSave=read.csv("randYears.csv")
A=10000 #Area of 100cm x 100cm quadrat
tlimit=2500 ## number of years to simulate
burn.in=500    # years to cut before calculations
sppList=c("ARTR","HECO","POSE","PSSP")
bigM=c(75,75,50,50)     #Set matrix dimension for each species
maxSize=c(3000,202,260,225)    # in cm^2: PSSP=225 HECO=202  POSE=260  ARTR=3000  # minSize=0.2  cm^2
Nyrs=22
doGroup=1  # NA for spatial avg., values 1-6 for a specific group
constant=F
NoOverlap.Inter=F
compScale=F
#============================================================
# (I) LOAD VITAL RATE PARAMETERS & FUNCTIONS
#============================================================
Nspp=length(sppList)
# Import and format growth parameters
# then define growth function
GparMCMC <- list()
for(jjj in 1:tlimit){
# growth parameters
Gpars=list(intcpt=rep(NA,Nspp),intcpt.yr=matrix(0,Nyrs,Nspp),intcpt.gr=matrix(0,6,Nspp),
slope=rep(NA,Nspp),slope.yr=matrix(0,Nyrs,Nspp),
nb=matrix(0,Nspp,Nspp),alpha=matrix(NA,Nspp,Nspp),
sigma2.a=rep(NA,Nspp),sigma2.b=rep(NA,Nspp))
#Get random row selection from the MCMC chain
mcDraw <- sample(seq(1,2000,1), size = 1)
for(i in 1:Nspp){
infile=paste("growth/Growth_paramsMCMC_",sppList[i],".rds",sep="")
Gdata=readRDS(infile)
Gdata <- as.data.frame(Gdata[mcDraw,]) #get one row from the MCMC chain
Gdata$Coef <- c(rep("W", 4),
rep("W.tau", 1),
rep("Group", 6),
rep("Intercept", 1),
rep("Intercept.tau", 1),
rep("Intercept.yr", 22),
rep("logarea.t0", 1),
rep("logarea.t0.tau", 1),
rep("logarea.t0.yr", 22),
rep("sigma2.a", 1),
rep("tauGroup", 1),
rep("sigma2.b", 1))
colnames(Gdata)[1] <- "value"
Gpars$intcpt[i]=Gdata$value[which(Gdata$Coef=="Intercept")]
tmp=which(Gdata$Coef=="Group")
if(length(tmp)>0) Gpars$intcpt.gr[,i]=Gdata$value[tmp]
tmp=which(Gdata$Coef=="Intercept.yr")
if(length(tmp)>0) Gpars$intcpt.yr[,i]=Gdata$value[tmp]
tmp=which(Gdata$Coef=="logarea.t0")
Gpars$slope[i]=Gdata$value[tmp]
# random effects on slope
tmp=which(Gdata$Coef=="logarea.t0.yr")
if(length(tmp)>0) Gpars$slope.yr[,i]=Gdata$value[tmp]
# get competition coefficients
tmp=which(Gdata$Coef=="W")
if(length(tmp)>0) Gpars$nb[i,]=Gdata$value[tmp]
alphaG <- read.csv("./growth/alphaGrowth.csv")
Gpars$alpha[i,]=alphaG$alpha
Gpars$sigma2.a[i]=Gdata$value[which(Gdata$Coef=="sigma2.a")]
Gpars$sigma2.b[i]=Gdata$value[which(Gdata$Coef=="sigma2.b")]
} # next i
rm(Gdata)
GparMCMC[[length(GparMCMC)+1]] <- Gpars
} #end list loop
# Import and format growth parameters
# then define growth function
GparMCMC <- list()
for(jjj in 1:tlimit){
# growth parameters
Gpars=list(intcpt=rep(NA,Nspp),intcpt.yr=matrix(0,Nyrs,Nspp),intcpt.gr=matrix(0,6,Nspp),
slope=rep(NA,Nspp),slope.yr=matrix(0,Nyrs,Nspp),
nb=matrix(0,Nspp,Nspp),alpha=matrix(NA,Nspp,Nspp),
sigma2.a=rep(NA,Nspp),sigma2.b=rep(NA,Nspp))
#Get random row selection from the MCMC chain
mcDraw <- sample(seq(1,2000,1), size = 1)
for(i in 1:Nspp){
infile=paste("growth/Growth_paramsMCMC_",sppList[i],".rds",sep="")
Gdata=readRDS(infile)
Gdata <- as.data.frame(Gdata[mcDraw,]) #get one row from the MCMC chain
Gdata$Coef <- c(rep("W", 4),
rep("W.tau", 1),
rep("Group", 6),
rep("Intercept", 1),
rep("Intercept.tau", 1),
rep("Intercept.yr", 22),
rep("logarea.t0", 1),
rep("logarea.t0.tau", 1),
rep("logarea.t0.yr", 22),
rep("sigma2.a", 1),
rep("tauGroup", 1),
rep("sigma2.b", 1))
colnames(Gdata)[1] <- "value"
Gpars$intcpt[i]=Gdata$value[which(Gdata$Coef=="Intercept")]
tmp=which(Gdata$Coef=="Group")
if(length(tmp)>0) Gpars$intcpt.gr[,i]=Gdata$value[tmp]
tmp=which(Gdata$Coef=="Intercept.yr")
if(length(tmp)>0) Gpars$intcpt.yr[,i]=Gdata$value[tmp]
tmp=which(Gdata$Coef=="logarea.t0")
Gpars$slope[i]=Gdata$value[tmp]
# random effects on slope
tmp=which(Gdata$Coef=="logarea.t0.yr")
if(length(tmp)>0) Gpars$slope.yr[,i]=Gdata$value[tmp]
# get competition coefficients
tmp=which(Gdata$Coef=="W")
if(length(tmp)>0) Gpars$nb[i,]=Gdata$value[tmp]
alphaG <- read.csv("./growth/alphaGrowth.csv")
Gpars$alpha[i,]=alphaG$alpha
Gpars$sigma2.a[i]=Gdata$value[which(Gdata$Coef=="sigma2.a")]
Gpars$sigma2.b[i]=Gdata$value[which(Gdata$Coef=="sigma2.b")]
} # next i
rm(Gdata)
GparMCMC[[length(GparMCMC)+1]] <- Gpars
print(paste("Done with parameter set ", jjj, "out of", tlimit, "."))
} #end list loop
GparMCMC[[1]]
