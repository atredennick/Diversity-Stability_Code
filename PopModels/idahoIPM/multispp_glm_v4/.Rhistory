n2dead <- length(which(finals[,2]==0))
plotD <- c(n1dead, n2dead, (asims - (n1dead+n2dead)))
plotD
barplot(plotD)
barplot(plotD, names.arg = c("Spp 1 Extinct", "Spp 2 Extinct", "Coexistence"))
barplot(plotD, names.arg = c("Spp 1 Extinct", "Spp 2 Extinct", "Coexistence"), horiz = TRUE)
par(las=2)
barplot(plotD, names.arg = c("Spp 1 Extinct", "Spp 2 Extinct", "Coexistence"))
par(las=3)
barplot(plotD, names.arg = c("Spp 1 Extinct", "Spp 2 Extinct", "Coexistence"))
par(las=4)
barplot(plotD, names.arg = c("Spp 1 Extinct", "Spp 2 Extinct", "Coexistence"))
par(las=1)
barplot(plotD, names.arg = c("Spp 1 Extinct", "Spp 2 Extinct", "Coexistence"))
####
#### Loop over simulations to get a feel for effect of stochasticity
####
r <- c(0.5, 0.5)
K <- c(100, 100)
aHet <- c(1, 1)
aCon <- c(1, 1)
tsims <- 5000
asims <- 100
finals <- matrix(NA, ncol=2, nrow=asims)
for(i in 1:asims){
N <- matrix(NA, nrow=tsims, ncol=length(r))
N[1,] <- c(5, 5)
Zvar <- 0.02
Zcov <- -0.01
sigma <- matrix(data=c(Zvar,Zcov,Zcov,Zvar),nrow=2,ncol=2)
z <- rmvnorm(tsims,c(0,0),sigma)
for(t in 2:tsims){
N[t,] <- LVfunc(r, K, aHet, aCon, N=N[t-1,], z=z[t-1,])
}
finals[i,] <- N[tsims,]
}
n1dead <- length(which(finals[,1]==0))
n2dead <- length(which(finals[,2]==0))
plotD <- c(n1dead, n2dead, (asims - (n1dead+n2dead)))
par(las=1)
barplot(plotD, names.arg = c("Spp 1 Extinct", "Spp 2 Extinct", "Coexistence"))
28*40
1120*4
####
#### LV COMPETITION; STOCHASTIC VERSION
####
library(mvtnorm)
####
#### Lotka-Volterra Function
####
LVfunc <- function(r, K, aHet, aCon, N, z){
newN <- numeric(length(N))
for(i in 1:length(N)){
newN[i] <- N[i] + N[i] * (r[i] * ((K[i]-aHet[i]*N[i]-aCon[-i]*N[-i])/K[i])+z[i])
}
newN[newN<0.001] <- 0
return(newN)
}
####
#### Parameters
####
r <- c(0.5, 0.5)
K <- c(100, 100)
aHet <- c(1, 1)
aCon <- c(0.99, 0.99)
1/aCon[2]
K[1]/K[2]
aCon[1]
tsims <- 5000
N <- matrix(NA, nrow=tsims, ncol=length(r))
N[1,] <- c(5, 5)
Zvar <- 0.02
Zcov <- 0.01
sigma <- matrix(data=c(Zvar,Zcov,Zcov,Zvar),nrow=2,ncol=2)
z <- rmvnorm(tsims,c(0,0),sigma)
####
#### Run simulation
####
for(t in 2:tsims){
N[t,] <- LVfunc(r, K, aHet, aCon, N=N[t-1,], z=z[t-1,])
}
####
#### Plot Results
####
matplot(c(1:tsims), N, type="l", lwd=1, main=round(N[tsims,]))
####
#### Loop over simulations to get a feel for effect of stochasticity
####
r <- c(0.5, 0.5)
K <- c(100, 100)
aHet <- c(1, 1)
aCon <- c(1, 1)
tsims <- 5000
asims <- 100
finals <- matrix(NA, ncol=2, nrow=asims)
for(i in 1:asims){
N <- matrix(NA, nrow=tsims, ncol=length(r))
N[1,] <- c(5, 5)
Zvar <- 0.02
Zcov <- 0.01
sigma <- matrix(data=c(Zvar,Zcov,Zcov,Zvar),nrow=2,ncol=2)
z <- rmvnorm(tsims,c(0,0),sigma)
for(t in 2:tsims){
N[t,] <- LVfunc(r, K, aHet, aCon, N=N[t-1,], z=z[t-1,])
}
finals[i,] <- N[tsims,]
}
n1dead <- length(which(finals[,1]==0))
n2dead <- length(which(finals[,2]==0))
plotD <- c(n1dead, n2dead, (asims - (n1dead+n2dead)))
par(las=1)
barplot(plotD, names.arg = c("Spp 1 Extinct", "Spp 2 Extinct", "Coexistence"))
####
#### LV COMPETITION; STOCHASTIC VERSION
####
library(mvtnorm)
####
#### Lotka-Volterra Function
####
LVfunc <- function(r, K, aHet, aCon, N, z){
newN <- numeric(length(N))
for(i in 1:length(N)){
newN[i] <- N[i] + N[i] * (r[i] * ((K[i]-aHet[i]*N[i]-aCon[-i]*N[-i])/K[i])+z[i])
}
newN[newN<0.001] <- 0
return(newN)
}
####
#### Parameters
####
r <- c(0.5, 0.5)
K <- c(100, 100)
aHet <- c(1, 1)
aCon <- c(0.99, 0.99)
1/aCon[2]
K[1]/K[2]
aCon[1]
tsims <- 5000
N <- matrix(NA, nrow=tsims, ncol=length(r))
N[1,] <- c(5, 5)
Zvar <- 0.02
Zcov <- 0.01
sigma <- matrix(data=c(Zvar,Zcov,Zcov,Zvar),nrow=2,ncol=2)
z <- rmvnorm(tsims,c(0,0),sigma)
####
#### Run simulation
####
for(t in 2:tsims){
N[t,] <- LVfunc(r, K, aHet, aCon, N=N[t-1,], z=z[t-1,])
}
####
#### Plot Results
####
matplot(c(1:tsims), N, type="l", lwd=1, main=round(N[tsims,]))
####
#### Loop over simulations to get a feel for effect of stochasticity
####
r <- c(0.5, 0.5)
K <- c(100, 100)
aHet <- c(1, 1)
aCon <- c(1, 1)
tsims <- 5000
asims <- 100
finals <- matrix(NA, ncol=2, nrow=asims)
for(i in 1:asims){
N <- matrix(NA, nrow=tsims, ncol=length(r))
N[1,] <- c(5, 5)
Zvar <- 0.02
Zcov <- -0.01
sigma <- matrix(data=c(Zvar,Zcov,Zcov,Zvar),nrow=2,ncol=2)
z <- rmvnorm(tsims,c(0,0),sigma)
for(t in 2:tsims){
N[t,] <- LVfunc(r, K, aHet, aCon, N=N[t-1,], z=z[t-1,])
}
finals[i,] <- N[tsims,]
}
n1dead <- length(which(finals[,1]==0))
n2dead <- length(which(finals[,2]==0))
plotD <- c(n1dead, n2dead, (asims - (n1dead+n2dead)))
par(las=1)
barplot(plotD, names.arg = c("Spp 1 Extinct", "Spp 2 Extinct", "Coexistence"))
####
#### LV COMPETITION
####
####
#### Lotka-Volterra Function
####
LVfunc <- function(r, K, aHet, aCon, N){
newN <- numeric(length(N))
for(i in 1:length(N)){
newN[i] <- N[i] + r[i]*N[i] * ((K[i]-aHet[i]*N[i]-aCon[-i]*N[-i])/K[i])
}
newN[newN<0.001] <- 0
return(newN)
}
####
#### Parameters
####
r <- c(0.5, 0.5)
K <- c(110, 90)
aHet <- c(1, 1)
aCon <- c(1.1, 1.1)
1/aCon[2]
K[1]/K[2]
aCon[1]
tsims <- 500
N <- matrix(NA, nrow=tsims, ncol=length(r))
N[1,] <- c(5, 5)
####
#### Run simulation
####
for(t in 2:tsims){
N[t,] <- LVfunc(r, K, aHet, aCon, N=N[t-1,])
}
####
#### Plot Results
####
matplot(c(1:tsims), N, type="l", lwd=4, col="grey25", main=round(N[tsims,]))
####
#### LV COMPETITION
####
####
#### Lotka-Volterra Function
####
LVfunc <- function(r, K, aHet, aCon, N){
newN <- numeric(length(N))
for(i in 1:length(N)){
newN[i] <- N[i] + r[i]*N[i] * ((K[i]-aHet[i]*N[i]-aCon[-i]*N[-i])/K[i])
}
newN[newN<0.001] <- 0
return(newN)
}
####
#### Parameters
####
r <- c(0.5, 0.5)
K <- c(110, 90)
aHet <- c(1, 1)
aCon <- c(1.1, 1.1)
1/aCon[2]
K[1]/K[2]
aCon[1]
tsims <- 500
N <- matrix(NA, nrow=tsims, ncol=length(r))
N[1,] <- c(5, 5)
####
#### Run simulation
####
for(t in 2:tsims){
N[t,] <- LVfunc(r, K, aHet, aCon, N=N[t-1,])
}
####
#### Plot Results
####
matplot(c(1:tsims), N, type="l", lwd=4, col="grey25", main=round(N[tsims,]))
####
#### LV COMPETITION
####
####
#### Lotka-Volterra Function
####
LVfunc <- function(r, K, aHet, aCon, N){
newN <- numeric(length(N))
for(i in 1:length(N)){
newN[i] <- N[i] + r[i]*N[i] * ((K[i]-aHet[i]*N[i]-aCon[-i]*N[-i])/K[i])
}
newN[newN<0.001] <- 0
return(newN)
}
####
#### Parameters
####
r <- c(0.5, 0.5)
K <- c(110, 90)
aHet <- c(1, 1)
aCon <- c(1.1, 1.1)
1/aCon[2]
K[1]/K[2]
aCon[1]
tsims <- 500
N <- matrix(NA, nrow=tsims, ncol=length(r))
N[1,] <- c(5, 5)
####
#### Run simulation
####
for(t in 2:tsims){
N[t,] <- LVfunc(r, K, aHet, aCon, N=N[t-1,])
}
####
#### Plot Results
####
matplot(c(1:tsims), N, type="l", lwd=4, col="grey25", main=round(N[tsims,]))
####
#### LV COMPETITION
####
####
#### Lotka-Volterra Function
####
LVfunc <- function(r, K, aHet, aCon, N){
newN <- numeric(length(N))
for(i in 1:length(N)){
newN[i] <- N[i] + r[i]*N[i] * ((K[i]-aHet[i]*N[i]-aCon[-i]*N[-i])/K[i])
}
newN[newN<0.001] <- 0
return(newN)
}
####
#### Parameters
####
r <- c(0.5, 0.5)
K <- c(110, 90)
aHet <- c(1, 1)
aCon <- c(1.1, 1.1)
1/aCon[2]
K[1]/K[2]
aCon[1]
tsims <- 500
N <- matrix(NA, nrow=tsims, ncol=length(r))
N[1,] <- c(5, 5)
####
#### Run simulation
####
for(t in 2:tsims){
N[t,] <- LVfunc(r, K, aHet, aCon, N=N[t-1,])
}
####
#### Plot Results
####
matplot(c(1:tsims), N, type="l", lwd=4, col="grey25", main=round(N[tsims,]))
####
#### LV COMPETITION
####
####
#### Lotka-Volterra Function
####
LVfunc <- function(r, K, aHet, aCon, N){
newN <- numeric(length(N))
for(i in 1:length(N)){
newN[i] <- N[i] + r[i]*N[i] * ((K[i]-aHet[i]*N[i]-aCon[-i]*N[-i])/K[i])
}
newN[newN<0.001] <- 0
return(newN)
}
####
#### Parameters
####
r <- c(0.5, 0.5)
K <- c(110, 90)
aHet <- c(1, 1)
aCon <- c(1.1, 1.1)
1/aCon[2]
K[1]/K[2]
aCon[1]
tsims <- 500
N <- matrix(NA, nrow=tsims, ncol=length(r))
N[1,] <- c(5, 5)
####
#### Run simulation
####
for(t in 2:tsims){
N[t,] <- LVfunc(r, K, aHet, aCon, N=N[t-1,])
}
####
#### Plot Results
####
matplot(c(1:tsims), N, type="l", lwd=4, col="grey25", main=round(N[tsims,]))
####
#### LV COMPETITION
####
####
#### Lotka-Volterra Function
####
LVfunc <- function(r, K, aHet, aCon, N){
newN <- numeric(length(N))
for(i in 1:length(N)){
newN[i] <- N[i] + r[i]*N[i] * ((K[i]-aHet[i]*N[i]-aCon[-i]*N[-i])/K[i])
}
newN[newN<0.001] <- 0
return(newN)
}
####
#### Parameters
####
r <- c(0.5, 0.5)
K <- c(90, 90)
aHet <- c(1, 1)
aCon <- c(1.1, 1.1)
1/aCon[2]
K[1]/K[2]
aCon[1]
tsims <- 500
N <- matrix(NA, nrow=tsims, ncol=length(r))
N[1,] <- c(5, 5)
####
#### Run simulation
####
for(t in 2:tsims){
N[t,] <- LVfunc(r, K, aHet, aCon, N=N[t-1,])
}
####
#### Plot Results
####
matplot(c(1:tsims), N, type="l", lwd=4, col="grey25", main=round(N[tsims,]))
####
#### LV COMPETITION; STOCHASTIC VERSION
####
library(mvtnorm)
####
#### Lotka-Volterra Function
####
LVfunc <- function(r, K, aHet, aCon, N, z){
newN <- numeric(length(N))
for(i in 1:length(N)){
newN[i] <- N[i] + N[i] * (r[i] * ((K[i]-aHet[i]*N[i]-aCon[-i]*N[-i])/K[i])+z[i])
}
newN[newN<0.001] <- 0
return(newN)
}
####
#### Parameters
####
r <- c(0.5, 0.5)
K <- c(100, 100)
aHet <- c(1, 1)
aCon <- c(1.1, 1.1)
1/aCon[2]
K[1]/K[2]
aCon[1]
tsims <- 5000
N <- matrix(NA, nrow=tsims, ncol=length(r))
N[1,] <- c(5, 5)
Zvar <- 0.02
Zcov <- 0.01
sigma <- matrix(data=c(Zvar,Zcov,Zcov,Zvar),nrow=2,ncol=2)
z <- rmvnorm(tsims,c(0,0),sigma)
####
#### Run simulation
####
for(t in 2:tsims){
N[t,] <- LVfunc(r, K, aHet, aCon, N=N[t-1,], z=z[t-1,])
}
####
#### Plot Results
####
matplot(c(1:tsims), N, type="l", lwd=1, main=round(N[tsims,]))
####
#### Loop over simulations to get a feel for effect of stochasticity
####
r <- c(0.5, 0.5)
K <- c(100, 100)
aHet <- c(1, 1)
aCon <- c(1, 1)
tsims <- 5000
asims <- 100
finals <- matrix(NA, ncol=2, nrow=asims)
for(i in 1:asims){
N <- matrix(NA, nrow=tsims, ncol=length(r))
N[1,] <- c(5, 5)
Zvar <- 0.02
Zcov <- -0.01
sigma <- matrix(data=c(Zvar,Zcov,Zcov,Zvar),nrow=2,ncol=2)
z <- rmvnorm(tsims,c(0,0),sigma)
for(t in 2:tsims){
N[t,] <- LVfunc(r, K, aHet, aCon, N=N[t-1,], z=z[t-1,])
}
finals[i,] <- N[tsims,]
}
n1dead <- length(which(finals[,1]==0))
n2dead <- length(which(finals[,2]==0))
plotD <- c(n1dead, n2dead, (asims - (n1dead+n2dead)))
par(las=1)
barplot(plotD, names.arg = c("Spp 1 Extinct", "Spp 2 Extinct", "Coexistence"))
setwd("~/Repos/Diversity_Stability/PopModels/idahoIPM/multispp_glm_v4/simulations")
# Multispecies, spatially implicit IPM
# This version makes it possible to assume "no overlap"
# for intraspecific competition only or intra- and interspecific competition
#This version allows you to "grow" each species in isolation or in mixture to obtain
#the effect of interspecific competition on growth -- basically the difference in
#FROM PETER: Basically, we simulate a species' intrinsic growth rate (geometric mean across the year specific rates)
#and then simulate the species' invasion growth rate (growth rate in the presence of competitors at their
#equilibrium abundances). The bigger the difference, the more sensitive a species is to competition.
#If there is no difference, then interspecific competition has zero effect. You can also get facilitation
#(invasion growth rate > intrinsic growth rate).
#We do this in a fluctuating environment, so these intrinsic growth rates are different than in the constant environment
#Sensitivity to competition: S = 1 - (r[invasion]-r[alone])
setwd(dir = "../")
invade=TRUE #FALSE for intrinsic growth rate; TRUE for invasion growth rate
ifelse(invade==TRUE,
outfile <- "./simulations/invasionGrowthRates_YrFluct.csv",
outfile <- "./simulations/intrinsicGrowthRates_YrFluct.csv")
# ATT 9/26/14
A=10000 #Area of 100cm x 100cm quadrat
tlimit=1000 ## number of years to simulate
burn.in=100    # years to cut before calculations
sppList=c("ARTR","HECO","POSE","PSSP")
bigM=c(75,75,50,50)     #Set matrix dimension for each species
maxSize=c(3000,202,260,225)    # in cm^2: PSSP=225 HECO=202  POSE=260  ARTR=3000  # minSize=0.2  cm^2
Nyrs=22
doGroup=NA  # NA for spatial avg., values 1-6 for a specific group
constant=F  # constant environment
NoOverlap.Inter=T # no overlap of heterospecifics
compScale=F # not well implemented, but for rescaling competition coefficients
maxR <- numeric(length(sppList))
jjjj=1
Nspp=length(sppList)
# set up survival parameters and function
source("./survival/import2ipm_noOverlap.r")
# set up growth parameters and function
source("./growth/import2ipm_noOverlap.r")
# set up recruitment parameters and function
source("./recruitment/import2ipm.r")
Gpars
